package services

import (
	"archive/zip"
	"bytes"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"app/app/models"

	"github.com/str20tbl/revel"
)

// LaTeXExporter handles LaTeX document generation and export
type LaTeXExporter struct {
	templateDir string
}

// NewLaTeXExporter creates a new LaTeX exporter
func NewLaTeXExporter() *LaTeXExporter {
	return &LaTeXExporter{
		templateDir: "app/templates/latex",
	}
}

// GenerateDocument creates a LaTeX document from template and data
func (e *LaTeXExporter) GenerateDocument(data *AnalysisResponse) (string, error) {
	tmplPath := filepath.Join(e.templateDir, "document.tmpl")
	tmpl, err := template.ParseFiles(tmplPath)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %v", err)
	}

	// Prepare template data
	templateData := e.prepareTemplateData(data)

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	return buf.String(), nil
}

// GenerateSectionDocument generates a LaTeX document for a single analytics section
func (e *LaTeXExporter) GenerateSectionDocument(sectionName string, data *AnalysisResponse) (string, error) {
	// Map section names to template methods
	sectionGenerators := map[string]func(*AnalysisResponse) (string, error){
		"executive-summary":       e.generateExecutiveSummarySection,
		"model-comparison":        e.generateModelComparisonSection,
		"inter-rater-reliability": e.generateInterRaterReliabilitySection,
		"linguistic-patterns":     e.generateLinguisticPatternsSection,
		"error-costs":             e.generateErrorCostsSection,
		"error-attribution":       e.generateErrorAttributionSection,
		"challenging-words":       e.generateChallengingWordsSection,
		"character-errors":        e.generateCharacterErrorsSection,
		"cer-distribution":        e.generateCERDistributionSection,
		"consistency":             e.generateConsistencySection,
		"examples":                e.generateExamplesSection,
		"study-design":            e.generateStudyDesignSection,
		"recommendations":         e.generateRecommendationsSection,
		"hybrid-analysis":         e.generateHybridAnalysisSection, // Merged hybrid best-case + implications
		// Aliases for frontend section names
		"comprehensive-errors":    e.generateErrorAttributionSection, // Maps to error attribution
		"word-length":             e.generateWordLengthSection,       // Dedicated word-length generator
	}

	generator, ok := sectionGenerators[sectionName]
	if !ok {
		return "", fmt.Errorf("unknown section: %s", sectionName)
	}

	// Generate section content
	content, err := generator(data)
	if err != nil {
		return "", fmt.Errorf("failed to generate section %s: %w", sectionName, err)
	}

	// Wrap in minimal LaTeX document structure
	doc := fmt.Sprintf(`\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue}

\title{Dysgair Analytics: %s}
\author{Generated by Dysgair}
\date{\today}

\begin{document}
\maketitle

%s

\end{document}`, strings.Title(strings.Replace(sectionName, "-", " ", -1)), content)

	return doc, nil
}

// Section generator methods for individual exports

func (e *LaTeXExporter) generateExecutiveSummarySection(data *AnalysisResponse) (string, error) {
	if data.ExecutiveSummary == nil {
		return "", fmt.Errorf("executive summary data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Executive Summary}\n\n")
	content.WriteString("This section provides a high-level overview of the key findings from comparing Whisper and Wav2Vec2 ASR models on Welsh pronunciation data.\n\n")

	es := data.ExecutiveSummary

	// Sample overview
	content.WriteString(fmt.Sprintf("\\textbf{Corpus:} %d recordings covering %d unique words\n\n", es.TotalRecordings, es.TotalWords))

	// Overall winner
	if es.OverallWinner != "" {
		content.WriteString(fmt.Sprintf("\\textbf{Overall Winner:} %s\n\n", EscapeLaTeX(es.OverallWinner)))
	}

	// Comprehensive CER comparison table
	content.WriteString("\\subsection{Character Error Rate Comparison}\n\n")
	content.WriteString("\\begin{table}[h]\n\\centering\n")
	content.WriteString("\\begin{tabular}{lcc}\n\\toprule\n")
	content.WriteString("Metric & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

	if es.RawMetrics != nil {
		content.WriteString("\\textbf{Raw Metrics (True ASR Quality)} & & \\\\\n")
		content.WriteString(fmt.Sprintf("Mean CER & %.2f\\%% & %.2f\\%% \\\\\n",
			es.RawMetrics.WhisperCERMean, es.RawMetrics.Wav2Vec2CERMean))
		content.WriteString(fmt.Sprintf("Difference & \\multicolumn{2}{c}{%.2f pp} \\\\\n",
			es.RawMetrics.PercentagePointDifference))
		content.WriteString(fmt.Sprintf("Relative Improvement & \\multicolumn{2}{c}{%.1f\\%%} \\\\\n",
			es.RawMetrics.RelativeImprovement))
		content.WriteString(fmt.Sprintf("Winner & \\multicolumn{2}{c}{%s} \\\\\n",
			EscapeLaTeX(es.RawMetrics.Winner)))
		content.WriteString("[0.5em]\n")
	}

	if es.NormalizedMetrics != nil {
		content.WriteString("\\textbf{Normalized Metrics (Pedagogical)} & & \\\\\n")
		content.WriteString(fmt.Sprintf("Mean CER & %.2f\\%% & %.2f\\%% \\\\\n",
			es.NormalizedMetrics.WhisperCERMean, es.NormalizedMetrics.Wav2Vec2CERMean))
		content.WriteString(fmt.Sprintf("Difference & \\multicolumn{2}{c}{%.2f pp} \\\\\n",
			es.NormalizedMetrics.PercentagePointDifference))
		content.WriteString(fmt.Sprintf("Relative Improvement & \\multicolumn{2}{c}{%.1f\\%%} \\\\\n",
			es.NormalizedMetrics.RelativeImprovement))
		content.WriteString(fmt.Sprintf("Winner & \\multicolumn{2}{c}{%s} \\\\\n",
			EscapeLaTeX(es.NormalizedMetrics.Winner)))
	}

	content.WriteString("\\bottomrule\n\\end{tabular}\n")
	content.WriteString("\\caption{Executive Summary - Character Error Rate Comparison}\n")
	content.WriteString("\\label{tab:executive-summary}\n")
	content.WriteString("\\end{table}\n\n")

	// Key finding
	if es.KeyFinding != "" {
		content.WriteString("\\textbf{Key Finding:} ")
		content.WriteString(EscapeLaTeX(es.KeyFinding))
		content.WriteString("\n\n")
	}

	return content.String(), nil
}

func (e *LaTeXExporter) generateModelComparisonSection(data *AnalysisResponse) (string, error) {
	if data.ModelComparison == nil {
		return "", fmt.Errorf("model comparison data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Model Performance Comparison}\n\n")
	content.WriteString(fmt.Sprintf("Comprehensive statistical comparison of Whisper and Wav2Vec2 ASR models across %d recordings.\n\n", data.ModelComparison.SampleSize))

	// RAW Metrics - True ASR Quality
	if data.ModelComparison.Raw != nil && data.ModelComparison.Raw.CERAnalysis != nil {
		content.WriteString("\\subsection{Raw Metrics (True ASR Quality)}\n\n")
		content.WriteString("Raw metrics use strict character-level matching without normalization.\n\n")

		cerRaw := data.ModelComparison.Raw.CERAnalysis
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcc}\n\\toprule\n")
		content.WriteString("Statistic & Whisper & Wav2Vec2 \\\\\n\\midrule\n")
		content.WriteString(fmt.Sprintf("Mean & %.2f\\%% & %.2f\\%% \\\\\n",
			cerRaw.Whisper.Mean, cerRaw.Wav2Vec2.Mean))
		content.WriteString(fmt.Sprintf("Median & %.2f\\%% & %.2f\\%% \\\\\n",
			cerRaw.Whisper.Median, cerRaw.Wav2Vec2.Median))
		content.WriteString(fmt.Sprintf("Std Dev & %.2f & %.2f \\\\\n",
			cerRaw.Whisper.Std, cerRaw.Wav2Vec2.Std))
		content.WriteString(fmt.Sprintf("Min & %.2f\\%% & %.2f\\%% \\\\\n",
			cerRaw.Whisper.Min, cerRaw.Wav2Vec2.Min))
		content.WriteString(fmt.Sprintf("Max & %.2f\\%% & %.2f\\%% \\\\\n",
			cerRaw.Whisper.Max, cerRaw.Wav2Vec2.Max))

		if cerRaw.EffectSize != nil {
			content.WriteString("\\midrule\n")
			content.WriteString(fmt.Sprintf("Cohen's d & \\multicolumn{2}{c}{%.3f (%s)} \\\\\n",
				cerRaw.EffectSize.CohensD, cerRaw.EffectSize.Interpretation))
		}
		if cerRaw.Difference != nil {
			content.WriteString(fmt.Sprintf("Mean Difference & \\multicolumn{2}{c}{%.2f pp} \\\\\n",
				cerRaw.Difference.Mean))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Character Error Rate - Raw Metrics}\n")
		content.WriteString("\\label{tab:cer-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// NORMALIZED Metrics - Pedagogical Relevance
	if data.ModelComparison.Normalized != nil && data.ModelComparison.Normalized.CERAnalysis != nil {
		content.WriteString("\\subsection{Normalized Metrics (Pedagogical Relevance)}\n\n")
		content.WriteString("Normalized metrics use lenient matching that ignores punctuation, spacing, and capitalization errors, focusing on pronunciation accuracy.\n\n")

		cerNorm := data.ModelComparison.Normalized.CERAnalysis
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcc}\n\\toprule\n")
		content.WriteString("Statistic & Whisper & Wav2Vec2 \\\\\n\\midrule\n")
		content.WriteString(fmt.Sprintf("Mean & %.2f\\%% & %.2f\\%% \\\\\n",
			cerNorm.Whisper.Mean, cerNorm.Wav2Vec2.Mean))
		content.WriteString(fmt.Sprintf("Median & %.2f\\%% & %.2f\\%% \\\\\n",
			cerNorm.Whisper.Median, cerNorm.Wav2Vec2.Median))
		content.WriteString(fmt.Sprintf("Std Dev & %.2f & %.2f \\\\\n",
			cerNorm.Whisper.Std, cerNorm.Wav2Vec2.Std))
		content.WriteString(fmt.Sprintf("Min & %.2f\\%% & %.2f\\%% \\\\\n",
			cerNorm.Whisper.Min, cerNorm.Wav2Vec2.Min))
		content.WriteString(fmt.Sprintf("Max & %.2f\\%% & %.2f\\%% \\\\\n",
			cerNorm.Whisper.Max, cerNorm.Wav2Vec2.Max))

		if cerNorm.EffectSize != nil {
			content.WriteString("\\midrule\n")
			content.WriteString(fmt.Sprintf("Cohen's d & \\multicolumn{2}{c}{%.3f (%s)} \\\\\n",
				cerNorm.EffectSize.CohensD, cerNorm.EffectSize.Interpretation))
		}
		if cerNorm.Difference != nil {
			content.WriteString(fmt.Sprintf("Mean Difference & \\multicolumn{2}{c}{%.2f pp} \\\\\n",
				cerNorm.Difference.Mean))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Character Error Rate - Normalized Metrics}\n")
		content.WriteString("\\label{tab:cer-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Include chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=0.9\\textwidth]{charts/chartModelComparison.png}\n")
	content.WriteString("\\caption{Model Comparison - CER Comparison (Raw and Normalized)}\n")
	content.WriteString("\\label{fig:model-comparison}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateInterRaterReliabilitySection(data *AnalysisResponse) (string, error) {
	if data.InterRaterReliability == nil {
		return "", fmt.Errorf("inter-rater reliability data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Inter-Rater Reliability Analysis}\n\n")
	content.WriteString("Analysis of model agreement patterns. Shows how often both models agree on pronunciation correctness.\n\n")

	irr := data.InterRaterReliability

	// Agreement metrics table
	content.WriteString("\\subsection{Model Agreement Metrics}\n\n")
	content.WriteString("\\begin{table}[h]\n\\centering\n")
	content.WriteString("\\begin{tabular}{lc}\n\\toprule\n")
	content.WriteString("Metric & Value \\\\\n\\midrule\n")

	content.WriteString(fmt.Sprintf("Sample Size & %d \\\\\n", irr.SampleSize))
	content.WriteString(fmt.Sprintf("Agreement Rate & %.2f\\%% \\\\\n", irr.AgreementRate*100))

	content.WriteString("\\bottomrule\n\\end{tabular}\n")
	content.WriteString("\\caption{Inter-Rater Reliability Metrics}\n")
	content.WriteString("\\label{tab:inter-rater-metrics}\n")
	content.WriteString("\\end{table}\n\n")

	// Agreement patterns table
	if irr.AgreementCounts != nil {
		content.WriteString("\\subsection{Agreement Patterns}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lc}\n\\toprule\n")
		content.WriteString("Pattern & Count \\\\\n\\midrule\n")

		content.WriteString(fmt.Sprintf("Both Correct & %d \\\\\n", irr.AgreementCounts.BothCorrect))
		content.WriteString(fmt.Sprintf("Both Incorrect & %d \\\\\n", irr.AgreementCounts.BothIncorrect))
		content.WriteString(fmt.Sprintf("Whisper Only Correct & %d \\\\\n", irr.AgreementCounts.WhisperOnlyCorrect))
		content.WriteString(fmt.Sprintf("Wav2Vec2 Only Correct & %d \\\\\n", irr.AgreementCounts.Wav2Vec2OnlyCorrect))

		content.WriteString("\\midrule\n")
		totalAgreement := irr.AgreementCounts.BothCorrect + irr.AgreementCounts.BothIncorrect
		totalDisagreement := irr.AgreementCounts.WhisperOnlyCorrect + irr.AgreementCounts.Wav2Vec2OnlyCorrect
		content.WriteString(fmt.Sprintf("Total Agreement & %d \\\\\n", totalAgreement))
		content.WriteString(fmt.Sprintf("Total Disagreement & %d \\\\\n", totalDisagreement))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Model Agreement Patterns}\n")
		content.WriteString("\\label{tab:agreement-patterns}\n")
		content.WriteString("\\end{table}\n\n")
	}

	return content.String(), nil
}

func (e *LaTeXExporter) generateLinguisticPatternsSection(data *AnalysisResponse) (string, error) {
	if data.LinguisticPatterns == nil {
		return "", fmt.Errorf("linguistic patterns data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Linguistic Pattern Analysis}\n\n")
	content.WriteString("Analysis of error patterns across different phonological categories: vowels (a, e, i, o, u, w, y + diacritics), consonants, and Welsh digraphs (ll, ch, dd, ff, ng, rh, ph, th).\n\n")

	lp := data.LinguisticPatterns

	// Raw metrics table
	if lp.Raw != nil {
		content.WriteString("\\subsection{Raw Metrics Error Rates by Phonological Category}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccccc}\n\\toprule\n")
		content.WriteString("Category & \\multicolumn{3}{c}{Whisper} & \\multicolumn{3}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Total & Errors & Rate & Total & Errors & Rate \\\\\n\\midrule\n")

		if lp.Raw.Whisper != nil && lp.Raw.Wav2Vec2 != nil {
			// Vowels
			if lp.Raw.Whisper.Vowels != nil && lp.Raw.Wav2Vec2.Vowels != nil {
				content.WriteString(fmt.Sprintf("Vowels & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Raw.Whisper.Vowels.Total, lp.Raw.Whisper.Vowels.Errors, lp.Raw.Whisper.Vowels.ErrorRate,
					lp.Raw.Wav2Vec2.Vowels.Total, lp.Raw.Wav2Vec2.Vowels.Errors, lp.Raw.Wav2Vec2.Vowels.ErrorRate))
			}

			// Consonants
			if lp.Raw.Whisper.Consonants != nil && lp.Raw.Wav2Vec2.Consonants != nil {
				content.WriteString(fmt.Sprintf("Consonants & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Raw.Whisper.Consonants.Total, lp.Raw.Whisper.Consonants.Errors, lp.Raw.Whisper.Consonants.ErrorRate,
					lp.Raw.Wav2Vec2.Consonants.Total, lp.Raw.Wav2Vec2.Consonants.Errors, lp.Raw.Wav2Vec2.Consonants.ErrorRate))
			}

			// Digraphs
			if lp.Raw.Whisper.Digraphs != nil && lp.Raw.Wav2Vec2.Digraphs != nil {
				content.WriteString(fmt.Sprintf("Digraphs & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Raw.Whisper.Digraphs.Total, lp.Raw.Whisper.Digraphs.Errors, lp.Raw.Whisper.Digraphs.ErrorRate,
					lp.Raw.Wav2Vec2.Digraphs.Total, lp.Raw.Wav2Vec2.Digraphs.Errors, lp.Raw.Wav2Vec2.Digraphs.ErrorRate))
			}

			// Overall
			if lp.Raw.Whisper.Overall != nil && lp.Raw.Wav2Vec2.Overall != nil {
				content.WriteString("\\midrule\n")
				content.WriteString(fmt.Sprintf("Overall & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Raw.Whisper.Overall.Total, lp.Raw.Whisper.Overall.Errors, lp.Raw.Whisper.Overall.ErrorRate,
					lp.Raw.Wav2Vec2.Overall.Total, lp.Raw.Wav2Vec2.Overall.Errors, lp.Raw.Wav2Vec2.Overall.ErrorRate))
			}
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Phonological Error Patterns - Raw Metrics}\n")
		content.WriteString("\\label{tab:linguistic-patterns-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Normalized metrics table
	if lp.Normalized != nil {
		content.WriteString("\\subsection{Normalized Metrics Error Rates by Phonological Category}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccccc}\n\\toprule\n")
		content.WriteString("Category & \\multicolumn{3}{c}{Whisper} & \\multicolumn{3}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Total & Errors & Rate & Total & Errors & Rate \\\\\n\\midrule\n")

		if lp.Normalized.Whisper != nil && lp.Normalized.Wav2Vec2 != nil {
			// Vowels
			if lp.Normalized.Whisper.Vowels != nil && lp.Normalized.Wav2Vec2.Vowels != nil {
				content.WriteString(fmt.Sprintf("Vowels & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Normalized.Whisper.Vowels.Total, lp.Normalized.Whisper.Vowels.Errors, lp.Normalized.Whisper.Vowels.ErrorRate,
					lp.Normalized.Wav2Vec2.Vowels.Total, lp.Normalized.Wav2Vec2.Vowels.Errors, lp.Normalized.Wav2Vec2.Vowels.ErrorRate))
			}

			// Consonants
			if lp.Normalized.Whisper.Consonants != nil && lp.Normalized.Wav2Vec2.Consonants != nil {
				content.WriteString(fmt.Sprintf("Consonants & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Normalized.Whisper.Consonants.Total, lp.Normalized.Whisper.Consonants.Errors, lp.Normalized.Whisper.Consonants.ErrorRate,
					lp.Normalized.Wav2Vec2.Consonants.Total, lp.Normalized.Wav2Vec2.Consonants.Errors, lp.Normalized.Wav2Vec2.Consonants.ErrorRate))
			}

			// Digraphs
			if lp.Normalized.Whisper.Digraphs != nil && lp.Normalized.Wav2Vec2.Digraphs != nil {
				content.WriteString(fmt.Sprintf("Digraphs & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Normalized.Whisper.Digraphs.Total, lp.Normalized.Whisper.Digraphs.Errors, lp.Normalized.Whisper.Digraphs.ErrorRate,
					lp.Normalized.Wav2Vec2.Digraphs.Total, lp.Normalized.Wav2Vec2.Digraphs.Errors, lp.Normalized.Wav2Vec2.Digraphs.ErrorRate))
			}

			// Overall
			if lp.Normalized.Whisper.Overall != nil && lp.Normalized.Wav2Vec2.Overall != nil {
				content.WriteString("\\midrule\n")
				content.WriteString(fmt.Sprintf("Overall & %d & %d & %.2f\\%% & %d & %d & %.2f\\%% \\\\\n",
					lp.Normalized.Whisper.Overall.Total, lp.Normalized.Whisper.Overall.Errors, lp.Normalized.Whisper.Overall.ErrorRate,
					lp.Normalized.Wav2Vec2.Overall.Total, lp.Normalized.Wav2Vec2.Overall.Errors, lp.Normalized.Wav2Vec2.Overall.ErrorRate))
			}
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Phonological Error Patterns - Normalized Metrics}\n")
		content.WriteString("\\label{tab:linguistic-patterns-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add charts
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=0.9\\textwidth]{charts/chartLinguisticPatterns.png}\n")
	content.WriteString("\\caption{Phonological Error Patterns Comparison}\n")
	content.WriteString("\\label{fig:linguistic-patterns}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateErrorCostsSection(data *AnalysisResponse) (string, error) {
	if data.ErrorCosts == nil {
		return "", fmt.Errorf("error costs data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Pedagogical Error Cost Analysis}\n\n")
	content.WriteString("Analysis of false acceptance (harmful: accepting incorrect pronunciation) and false rejection (demotivating: rejecting correct pronunciation) rates from a pronunciation learning perspective.\n\n")

	ec := data.ErrorCosts

	// Raw metrics table
	if ec.Raw != nil && ec.Raw.Whisper != nil && ec.Raw.Wav2Vec2 != nil {
		content.WriteString("\\subsection{Raw Metrics Pedagogical Costs}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccc}\n\\toprule\n")
		content.WriteString("Metric & \\multicolumn{2}{c}{Whisper} & \\multicolumn{2}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Count & Rate & Count & Rate \\\\\n\\midrule\n")

		wRaw := ec.Raw.Whisper
		w2Raw := ec.Raw.Wav2Vec2

		content.WriteString(fmt.Sprintf("False Acceptance & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wRaw.FalseAcceptance.Count, wRaw.FalseAcceptance.Rate,
			w2Raw.FalseAcceptance.Count, w2Raw.FalseAcceptance.Rate))
		content.WriteString(fmt.Sprintf("False Rejection & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wRaw.FalseRejection.Count, wRaw.FalseRejection.Rate,
			w2Raw.FalseRejection.Count, w2Raw.FalseRejection.Rate))
		content.WriteString(fmt.Sprintf("True Positive & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wRaw.TruePositive.Count, wRaw.TruePositive.Rate,
			w2Raw.TruePositive.Count, w2Raw.TruePositive.Rate))
		content.WriteString(fmt.Sprintf("True Negative & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wRaw.TrueNegative.Count, wRaw.TrueNegative.Rate,
			w2Raw.TrueNegative.Count, w2Raw.TrueNegative.Rate))

		content.WriteString("\\midrule\n")
		content.WriteString(fmt.Sprintf("Safety Score & \\multicolumn{2}{c}{%.1f} & \\multicolumn{2}{c}{%.1f} \\\\\n",
			wRaw.PedagogicalSafetyScore, w2Raw.PedagogicalSafetyScore))
		content.WriteString(fmt.Sprintf("Risk Score & \\multicolumn{2}{c}{%.1f} & \\multicolumn{2}{c}{%.1f} \\\\\n",
			wRaw.PedagogicalRiskScore, w2Raw.PedagogicalRiskScore))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Pedagogical Error Costs - Raw Metrics}\n")
		content.WriteString("\\label{tab:error-costs-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Normalized metrics table
	if ec.Normalized != nil && ec.Normalized.Whisper != nil && ec.Normalized.Wav2Vec2 != nil {
		content.WriteString("\\subsection{Normalized Metrics Pedagogical Costs}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccc}\n\\toprule\n")
		content.WriteString("Metric & \\multicolumn{2}{c}{Whisper} & \\multicolumn{2}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Count & Rate & Count & Rate \\\\\n\\midrule\n")

		wNorm := ec.Normalized.Whisper
		w2Norm := ec.Normalized.Wav2Vec2

		content.WriteString(fmt.Sprintf("False Acceptance & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wNorm.FalseAcceptance.Count, wNorm.FalseAcceptance.Rate,
			w2Norm.FalseAcceptance.Count, w2Norm.FalseAcceptance.Rate))
		content.WriteString(fmt.Sprintf("False Rejection & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wNorm.FalseRejection.Count, wNorm.FalseRejection.Rate,
			w2Norm.FalseRejection.Count, w2Norm.FalseRejection.Rate))
		content.WriteString(fmt.Sprintf("True Positive & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wNorm.TruePositive.Count, wNorm.TruePositive.Rate,
			w2Norm.TruePositive.Count, w2Norm.TruePositive.Rate))
		content.WriteString(fmt.Sprintf("True Negative & %d & %.2f\\%% & %d & %.2f\\%% \\\\\n",
			wNorm.TrueNegative.Count, wNorm.TrueNegative.Rate,
			w2Norm.TrueNegative.Count, w2Norm.TrueNegative.Rate))

		content.WriteString("\\midrule\n")
		content.WriteString(fmt.Sprintf("Safety Score & \\multicolumn{2}{c}{%.1f} & \\multicolumn{2}{c}{%.1f} \\\\\n",
			wNorm.PedagogicalSafetyScore, w2Norm.PedagogicalSafetyScore))
		content.WriteString(fmt.Sprintf("Risk Score & \\multicolumn{2}{c}{%.1f} & \\multicolumn{2}{c}{%.1f} \\\\\n",
			wNorm.PedagogicalRiskScore, w2Norm.PedagogicalRiskScore))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Pedagogical Error Costs - Normalized Metrics}\n")
		content.WriteString("\\label{tab:error-costs-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=0.9\\textwidth]{charts/chartErrorCosts.png}\n")
	content.WriteString("\\caption{Pedagogical Error Costs Comparison}\n")
	content.WriteString("\\label{fig:error-costs}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateErrorAttributionSection(data *AnalysisResponse) (string, error) {
	if data.ErrorAttribution == nil {
		return "", fmt.Errorf("error attribution data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Error Attribution Analysis}\n\n")
	content.WriteString("Classification of transcriptions into: CORRECT (accurate pronunciation), ASR\\_ERROR (ASR model failure), USER\\_ERROR (pronunciation error), and AMBIGUOUS (unclear classification).\n\n")

	ea := data.ErrorAttribution

	// Raw metrics table
	if ea.Raw != nil {
		content.WriteString("\\subsection{Raw Metrics Error Distribution}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccc}\n\\toprule\n")
		content.WriteString("Category & \\multicolumn{2}{c}{Whisper} & \\multicolumn{2}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Count & \\% & Count & \\% \\\\\n\\midrule\n")

		if ea.Raw.WhisperDistribution != nil && ea.Raw.Wav2Vec2Distribution != nil {
			wCounts := ea.Raw.WhisperDistribution.Counts
			wPerc := ea.Raw.WhisperDistribution.Percentages
			w2Counts := ea.Raw.Wav2Vec2Distribution.Counts
			w2Perc := ea.Raw.Wav2Vec2Distribution.Percentages

			content.WriteString(fmt.Sprintf("CORRECT & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["CORRECT"], wPerc["CORRECT"], w2Counts["CORRECT"], w2Perc["CORRECT"]))
			content.WriteString(fmt.Sprintf("ASR ERROR & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["ASR_ERROR"], wPerc["ASR_ERROR"], w2Counts["ASR_ERROR"], w2Perc["ASR_ERROR"]))
			content.WriteString(fmt.Sprintf("USER ERROR & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["USER_ERROR"], wPerc["USER_ERROR"], w2Counts["USER_ERROR"], w2Perc["USER_ERROR"]))
			content.WriteString(fmt.Sprintf("AMBIGUOUS & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["AMBIGUOUS"], wPerc["AMBIGUOUS"], w2Counts["AMBIGUOUS"], w2Perc["AMBIGUOUS"]))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Error Attribution Distribution - Raw Metrics}\n")
		content.WriteString("\\label{tab:error-attribution-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Normalized metrics table
	if ea.Normalized != nil {
		content.WriteString("\\subsection{Normalized Metrics Error Distribution}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcccc}\n\\toprule\n")
		content.WriteString("Category & \\multicolumn{2}{c}{Whisper} & \\multicolumn{2}{c}{Wav2Vec2} \\\\\n")
		content.WriteString(" & Count & \\% & Count & \\% \\\\\n\\midrule\n")

		if ea.Normalized.WhisperDistribution != nil && ea.Normalized.Wav2Vec2Distribution != nil {
			wCounts := ea.Normalized.WhisperDistribution.Counts
			wPerc := ea.Normalized.WhisperDistribution.Percentages
			w2Counts := ea.Normalized.Wav2Vec2Distribution.Counts
			w2Perc := ea.Normalized.Wav2Vec2Distribution.Percentages

			content.WriteString(fmt.Sprintf("CORRECT & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["CORRECT"], wPerc["CORRECT"], w2Counts["CORRECT"], w2Perc["CORRECT"]))
			content.WriteString(fmt.Sprintf("ASR ERROR & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["ASR_ERROR"], wPerc["ASR_ERROR"], w2Counts["ASR_ERROR"], w2Perc["ASR_ERROR"]))
			content.WriteString(fmt.Sprintf("USER ERROR & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["USER_ERROR"], wPerc["USER_ERROR"], w2Counts["USER_ERROR"], w2Perc["USER_ERROR"]))
			content.WriteString(fmt.Sprintf("AMBIGUOUS & %d & %.1f\\%% & %d & %.1f\\%% \\\\\n",
				wCounts["AMBIGUOUS"], wPerc["AMBIGUOUS"], w2Counts["AMBIGUOUS"], w2Perc["AMBIGUOUS"]))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Error Attribution Distribution - Normalized Metrics}\n")
		content.WriteString("\\label{tab:error-attribution-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add charts
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=0.9\\textwidth]{charts/chartErrorAttribution.png}\n")
	content.WriteString("\\caption{Error Attribution Distribution Comparison}\n")
	content.WriteString("\\label{fig:error-attribution}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateChallengingWordsSection(data *AnalysisResponse) (string, error) {
	if data.WordDifficulty == nil {
		return "", fmt.Errorf("word difficulty data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Word Difficulty Analysis}\n\n")
	content.WriteString("Words ranked by average character error rate (CER) to identify ASR model challenges.\n\n")

	// RAW METRICS - Most Difficult Words
	if data.WordDifficulty.Raw != nil && len(data.WordDifficulty.Raw.MostDifficult) > 0 {
		content.WriteString("\\subsection{Most Difficult Words (Raw Metrics)}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lccccc}\n\\toprule\n")
		content.WriteString("Word & Whisper CER & Wav2Vec2 CER & Avg CER & Length & Attempts \\\\\n\\midrule\n")

		for i, word := range data.WordDifficulty.Raw.MostDifficult {
			if i >= 10 { // Top 10
				break
			}
			content.WriteString(fmt.Sprintf("%s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %d & %d \\\\\n",
				EscapeLaTeXShort(word.Word),
				word.WhisperAvgCER,
				word.Wav2Vec2AvgCER,
				word.AverageCER,
				word.WordLength,
				word.Attempts))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Top 10 Most Difficult Words - Raw Metrics}\n")
		content.WriteString("\\label{tab:words-difficult-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// RAW METRICS - Easiest Words
	if data.WordDifficulty.Raw != nil && len(data.WordDifficulty.Raw.Easiest) > 0 {
		content.WriteString("\\subsection{Easiest Words (Raw Metrics)}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lccccc}\n\\toprule\n")
		content.WriteString("Word & Whisper CER & Wav2Vec2 CER & Avg CER & Length & Attempts \\\\\n\\midrule\n")

		for i, word := range data.WordDifficulty.Raw.Easiest {
			if i >= 10 { // Top 10
				break
			}
			content.WriteString(fmt.Sprintf("%s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %d & %d \\\\\n",
				EscapeLaTeXShort(word.Word),
				word.WhisperAvgCER,
				word.Wav2Vec2AvgCER,
				word.AverageCER,
				word.WordLength,
				word.Attempts))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Top 10 Easiest Words - Raw Metrics}\n")
		content.WriteString("\\label{tab:words-easiest-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// NORMALIZED METRICS - Most Difficult Words
	if data.WordDifficulty.Normalized != nil && len(data.WordDifficulty.Normalized.MostDifficult) > 0 {
		content.WriteString("\\subsection{Most Difficult Words (Normalized Metrics)}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lccccc}\n\\toprule\n")
		content.WriteString("Word & Whisper CER & Wav2Vec2 CER & Avg CER & Length & Attempts \\\\\n\\midrule\n")

		for i, word := range data.WordDifficulty.Normalized.MostDifficult {
			if i >= 10 { // Top 10
				break
			}
			content.WriteString(fmt.Sprintf("%s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %d & %d \\\\\n",
				EscapeLaTeXShort(word.Word),
				word.WhisperAvgCER,
				word.Wav2Vec2AvgCER,
				word.AverageCER,
				word.WordLength,
				word.Attempts))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Top 10 Most Difficult Words - Normalized Metrics}\n")
		content.WriteString("\\label{tab:words-difficult-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=\\textwidth]{charts/chartTopDifficultWords.png}\n")
	content.WriteString("\\caption{Word Difficulty Comparison}\n")
	content.WriteString("\\label{fig:word-difficulty}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateCharacterErrorsSection(data *AnalysisResponse) (string, error) {
	if data.CharacterErrors == nil {
		return "", fmt.Errorf("character errors data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Character Error Analysis}\n\n")
	content.WriteString("Detailed analysis of character-level substitutions, insertions, and deletions.\n\n")

	content.WriteString("\\subsection{Error Rate by Character}\n\n")
	
	// Add charts
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=\\textwidth]{charts/chartCharacterErrorRate.png}\n")
	content.WriteString("\\caption{Character Error Rates}\n\\end{figure}\n\n")

	content.WriteString("\\subsection{Confusion Matrices}\n\n")
	content.WriteString("See generated confusion matrix tables for detailed character substitution patterns.\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateCERDistributionSection(data *AnalysisResponse) (string, error) {
	if data.WordDifficulty == nil {
		return "", fmt.Errorf("CER distribution data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{CER Distribution Across Words}\n\n")
	content.WriteString("Distribution of Character Error Rates across all unique words in the dataset.\n\n")

	// Add chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=\\textwidth]{charts/wordDifficulty.png}\n")
	content.WriteString("\\caption{CER Distribution}\n\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateWordLengthSection(data *AnalysisResponse) (string, error) {
	if data.WordLength == nil {
		return "", fmt.Errorf("word length data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Performance by Word Length}\n\n")
	content.WriteString("ASR performance analysis grouped by word length categories (character count). This analysis helps identify whether word length correlates with ASR difficulty.\n\n")

	wl := data.WordLength

	// Helper function to format category stats
	formatCategoryRow := func(label string, stats *LengthCategoryStats) string {
		if stats == nil {
			return fmt.Sprintf("%s & - & - & - & - & 0 \\\\\n", EscapeLaTeX(label))
		}
		return fmt.Sprintf("%s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %.1f\\%% & %d \\\\\n",
			EscapeLaTeX(label),
			stats.WhisperCER,
			stats.Wav2Vec2CER,
			stats.WhisperWER,
			stats.Wav2Vec2WER,
			stats.Count)
	}

	// Raw metrics table
	if wl.Raw != nil {
		content.WriteString("\\subsection{Raw Metrics (Strict Matching)}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{lccccc}\n\\toprule\n")
		content.WriteString("Length Category & Whisper CER & Wav2Vec2 CER & Whisper WER & Wav2Vec2 WER & Words \\\\\n\\midrule\n")

		content.WriteString(formatCategoryRow("1-3 chars (short)", wl.Raw.OneToThree))
		content.WriteString(formatCategoryRow("4-6 chars (medium)", wl.Raw.FourToSix))
		content.WriteString(formatCategoryRow("7-9 chars (long)", wl.Raw.SevenToNine))
		content.WriteString(formatCategoryRow("10+ chars (very long)", wl.Raw.TenPlus))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Performance by Word Length - Raw Metrics}\n")
		content.WriteString("\\label{tab:word-length-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Normalized metrics table
	if wl.Normalized != nil {
		content.WriteString("\\subsection{Normalized Metrics (Lenient Matching)}\n\n")
		content.WriteString("Pedagogically-relevant metrics excluding punctuation and formatting differences.\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{lccccc}\n\\toprule\n")
		content.WriteString("Length Category & Whisper CER & Wav2Vec2 CER & Whisper WER & Wav2Vec2 WER & Words \\\\\n\\midrule\n")

		content.WriteString(formatCategoryRow("1-3 chars (short)", wl.Normalized.OneToThree))
		content.WriteString(formatCategoryRow("4-6 chars (medium)", wl.Normalized.FourToSix))
		content.WriteString(formatCategoryRow("7-9 chars (long)", wl.Normalized.SevenToNine))
		content.WriteString(formatCategoryRow("10+ chars (very long)", wl.Normalized.TenPlus))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Performance by Word Length - Normalized Metrics}\n")
		content.WriteString("\\label{tab:word-length-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=\\textwidth]{charts/chartWordLength.png}\n")
	content.WriteString("\\caption{Word Length Performance Comparison}\n")
	content.WriteString("\\label{fig:word-length}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateConsistencySection(data *AnalysisResponse) (string, error) {
	if data.ConsistencyReliability == nil {
		return "", fmt.Errorf("consistency data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Consistency \\& Reliability Analysis}\n\n")
	content.WriteString("Analysis of variance and stability in model performance. Lower CV indicates more consistent performance; smaller IQR and lower 95th percentile indicate better reliability.\n\n")

	cr := data.ConsistencyReliability

	// Raw metrics table
	if cr.Raw != nil && cr.Raw.Whisper != nil && cr.Raw.Wav2Vec2 != nil {
		content.WriteString("\\subsection{Raw Metrics Consistency}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcc}\n\\toprule\n")
		content.WriteString("Metric & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

		content.WriteString(fmt.Sprintf("Coefficient of Variation (CV) & %.3f & %.3f \\\\\n",
			cr.Raw.Whisper.CV, cr.Raw.Wav2Vec2.CV))
		content.WriteString(fmt.Sprintf("Interquartile Range (IQR) & %.2f & %.2f \\\\\n",
			cr.Raw.Whisper.IQR, cr.Raw.Wav2Vec2.IQR))
		content.WriteString(fmt.Sprintf("95th Percentile (Worst Case) & %.2f\\%% & %.2f\\%% \\\\\n",
			cr.Raw.Whisper.Percentile95, cr.Raw.Wav2Vec2.Percentile95))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Consistency and Reliability Metrics - Raw}\n")
		content.WriteString("\\label{tab:consistency-raw}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Normalized metrics table
	if cr.Normalized != nil && cr.Normalized.Whisper != nil && cr.Normalized.Wav2Vec2 != nil {
		content.WriteString("\\subsection{Normalized Metrics Consistency}\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n")
		content.WriteString("\\begin{tabular}{lcc}\n\\toprule\n")
		content.WriteString("Metric & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

		content.WriteString(fmt.Sprintf("Coefficient of Variation (CV) & %.3f & %.3f \\\\\n",
			cr.Normalized.Whisper.CV, cr.Normalized.Wav2Vec2.CV))
		content.WriteString(fmt.Sprintf("Interquartile Range (IQR) & %.2f & %.2f \\\\\n",
			cr.Normalized.Whisper.IQR, cr.Normalized.Wav2Vec2.IQR))
		content.WriteString(fmt.Sprintf("95th Percentile (Worst Case) & %.2f\\%% & %.2f\\%% \\\\\n",
			cr.Normalized.Whisper.Percentile95, cr.Normalized.Wav2Vec2.Percentile95))

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Consistency and Reliability Metrics - Normalized}\n")
		content.WriteString("\\label{tab:consistency-normalized}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Add chart
	content.WriteString("\\begin{figure}[h]\n\\centering\n")
	content.WriteString("\\includegraphics[width=0.8\\textwidth]{charts/chartConsistency.png}\n")
	content.WriteString("\\caption{Model Consistency Comparison}\n")
	content.WriteString("\\label{fig:consistency}\n")
	content.WriteString("\\end{figure}\n\n")

	return content.String(), nil
}

func (e *LaTeXExporter) generateExamplesSection(data *AnalysisResponse) (string, error) {
	if data.QualitativeExamples == nil {
		return "", fmt.Errorf("qualitative examples data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Qualitative Examples}\n\n")
	content.WriteString("Representative transcription examples illustrating different model performance patterns.\n\n")

	examples := data.QualitativeExamples

	// Both correct
	if len(examples.BothCorrect) > 0 {
		content.WriteString("\\subsection{Both Models Correct}\n\n")
		content.WriteString("Examples where both Whisper and Wav2Vec2 correctly transcribed the pronunciation.\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{llll}\n\\toprule\n")
		content.WriteString("Target & Human & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

		for i, ex := range examples.BothCorrect {
			if i >= 5 { // Top 5 examples
				break
			}
			content.WriteString(fmt.Sprintf("%s & %s & %s & %s \\\\\n",
				EscapeLaTeXShort(ex.Target),
				EscapeLaTeXShort(ex.Human),
				EscapeLaTeXShort(ex.Whisper),
				EscapeLaTeXShort(ex.Wav2Vec2)))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Examples: Both Models Correct}\n")
		content.WriteString("\\label{tab:examples-both-correct}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Whisper only correct
	if len(examples.WhisperOnly) > 0 {
		content.WriteString("\\subsection{Whisper Correct, Wav2Vec2 Incorrect}\n\n")
		content.WriteString("Examples where Whisper succeeded but Wav2Vec2 failed.\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{llll}\n\\toprule\n")
		content.WriteString("Target & Human & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

		for i, ex := range examples.WhisperOnly {
			if i >= 5 {
				break
			}
			content.WriteString(fmt.Sprintf("%s & %s & %s & %s \\\\\n",
				EscapeLaTeXShort(ex.Target),
				EscapeLaTeXShort(ex.Human),
				EscapeLaTeXShort(ex.Whisper),
				EscapeLaTeXShort(ex.Wav2Vec2)))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Examples: Whisper Correct, Wav2Vec2 Incorrect}\n")
		content.WriteString("\\label{tab:examples-whisper-only}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Wav2Vec2 only correct
	if len(examples.Wav2Vec2Only) > 0 {
		content.WriteString("\\subsection{Wav2Vec2 Correct, Whisper Incorrect}\n\n")
		content.WriteString("Examples where Wav2Vec2 succeeded but Whisper failed.\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{llll}\n\\toprule\n")
		content.WriteString("Target & Human & Whisper & Wav2Vec2 \\\\\n\\midrule\n")

		for i, ex := range examples.Wav2Vec2Only {
			if i >= 5 {
				break
			}
			content.WriteString(fmt.Sprintf("%s & %s & %s & %s \\\\\n",
				EscapeLaTeXShort(ex.Target),
				EscapeLaTeXShort(ex.Human),
				EscapeLaTeXShort(ex.Whisper),
				EscapeLaTeXShort(ex.Wav2Vec2)))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Examples: Wav2Vec2 Correct, Whisper Incorrect}\n")
		content.WriteString("\\label{tab:examples-wav2vec2-only}\n")
		content.WriteString("\\end{table}\n\n")
	}

	// Pedagogically critical
	if len(examples.PedagogicallyCritical) > 0 {
		content.WriteString("\\subsection{Pedagogically Critical Errors}\n\n")
		content.WriteString("False acceptance cases where models accepted incorrect pronunciation (harmful for learning).\n\n")
		content.WriteString("\\begin{table}[h]\n\\centering\n\\small\n")
		content.WriteString("\\begin{tabular}{lllll}\n\\toprule\n")
		content.WriteString("Target & Human & Whisper & Wav2Vec2 & Critical Models \\\\\n\\midrule\n")

		for i, ex := range examples.PedagogicallyCritical {
			if i >= 5 {
				break
			}
			content.WriteString(fmt.Sprintf("%s & %s & %s & %s & %s \\\\\n",
				EscapeLaTeXShort(ex.Target),
				EscapeLaTeXShort(ex.Human),
				EscapeLaTeXShort(ex.Whisper),
				EscapeLaTeXShort(ex.Wav2Vec2),
				EscapeLaTeXShort(ex.CriticalModels)))
		}

		content.WriteString("\\bottomrule\n\\end{tabular}\n")
		content.WriteString("\\caption{Examples: Pedagogically Critical False Acceptances}\n")
		content.WriteString("\\label{tab:examples-critical}\n")
		content.WriteString("\\end{table}\n\n")
	}

	return content.String(), nil
}

func (e *LaTeXExporter) generateStudyDesignSection(data *AnalysisResponse) (string, error) {
	if data.StudyDesign == nil {
		return "", fmt.Errorf("study design data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Study Design \\& Limitations}\n\n")

	sd := data.StudyDesign

	// Study type
	if sd.StudyType != "" {
		content.WriteString(fmt.Sprintf("\\subsection{Study Type}\n%s\n\n", EscapeLaTeX(sd.StudyType)))
	}

	// Research design
	if sd.ResearchDesign != nil {
		content.WriteString("\\subsection{Research Design}\n\\begin{itemize}\n")
		content.WriteString(fmt.Sprintf("\\item Type: %s\n", EscapeLaTeX(sd.ResearchDesign.Type)))
		content.WriteString(fmt.Sprintf("\\item Participants: %d\n", sd.ResearchDesign.Participants))
		content.WriteString(fmt.Sprintf("\\item ASR Models: %d\n", sd.ResearchDesign.AsrModels))
		content.WriteString(fmt.Sprintf("\\item Unique Words: %d\n", sd.ResearchDesign.UniqueWords))
		content.WriteString(fmt.Sprintf("\\item Total Recordings: %d\n", sd.ResearchDesign.TotalRecordings))
		content.WriteString("\\end{itemize}\n\n")
	}

	// Data collection
	if sd.DataCollection != nil {
		content.WriteString("\\subsection{Data Collection}\n\\begin{itemize}\n")
		content.WriteString(fmt.Sprintf("\\item Task: %s\n", EscapeLaTeX(sd.DataCollection.Task)))
		content.WriteString(fmt.Sprintf("\\item Recordings per word: %s\n", EscapeLaTeX(sd.DataCollection.RecordingsPerWord)))
		content.WriteString(fmt.Sprintf("\\item Date range: %s\n", EscapeLaTeX(sd.DataCollection.DateRange)))
		if len(sd.DataCollection.AsrModelsCompared) > 0 {
			content.WriteString("\\item ASR models compared:\n\\begin{itemize}\n")
			for _, model := range sd.DataCollection.AsrModelsCompared {
				content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(model)))
			}
			content.WriteString("\\end{itemize}\n")
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	// Statistical approach
	if sd.StatisticalApproach != nil {
		content.WriteString("\\subsection{Statistical Approach}\n\\begin{itemize}\n")
		content.WriteString(fmt.Sprintf("\\item Paradigm: %s\n", EscapeLaTeX(sd.StatisticalApproach.Paradigm)))
		content.WriteString(fmt.Sprintf("\\item Rationale: %s\n", EscapeLaTeX(sd.StatisticalApproach.Rationale)))
		content.WriteString(fmt.Sprintf("\\item Effect size measure: %s\n", EscapeLaTeX(sd.StatisticalApproach.EffectSizeMeasure)))
		if len(sd.StatisticalApproach.PrimaryMetrics) > 0 {
			content.WriteString("\\item Primary metrics:\n\\begin{itemize}\n")
			for _, metric := range sd.StatisticalApproach.PrimaryMetrics {
				content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(metric)))
			}
			content.WriteString("\\end{itemize}\n")
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	// Limitations
	if len(sd.Limitations) > 0 {
		content.WriteString("\\subsection{Limitations}\n\\begin{itemize}\n")
		for _, item := range sd.Limitations {
			content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	// Strengths
	if len(sd.Strengths) > 0 {
		content.WriteString("\\subsection{Strengths}\n\\begin{itemize}\n")
		for _, item := range sd.Strengths {
			content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	return content.String(), nil
}

func (e *LaTeXExporter) generateRecommendationsSection(data *AnalysisResponse) (string, error) {
	if data.PracticalRecommendations == nil {
		return "", fmt.Errorf("recommendations data not available")
	}

	var content strings.Builder
	content.WriteString("\\section{Practical Recommendations}\n\n")

	rec := data.PracticalRecommendations

	// Primary recommendation
	if rec.PrimaryRecommendation != nil {
		content.WriteString("\\subsection{Primary Recommendation}\n")
		content.WriteString(fmt.Sprintf("\\textbf{Recommended Model:} %s\n\n",
			EscapeLaTeX(rec.PrimaryRecommendation.RecommendedModel)))
		content.WriteString(fmt.Sprintf("\\textbf{Rationale:} %s\n\n",
			EscapeLaTeX(rec.PrimaryRecommendation.Rationale)))
		content.WriteString(fmt.Sprintf("\\textbf{Confidence:} %s\n\n",
			EscapeLaTeX(rec.PrimaryRecommendation.Confidence)))
	}

	// Use cases
	if rec.UseCases != nil {
		content.WriteString("\\subsection{Use Cases}\n")

		if len(rec.UseCases.WhisperPreferred) > 0 {
			content.WriteString("\\subsubsection{When to prefer Whisper}\n\\begin{itemize}\n")
			for _, item := range rec.UseCases.WhisperPreferred {
				if item != "" {  // Filter out null/empty items
					content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
				}
			}
			content.WriteString("\\end{itemize}\n\n")
		}

		if len(rec.UseCases.Wav2Vec2Preferred) > 0 {
			content.WriteString("\\subsubsection{When to prefer Wav2Vec2}\n\\begin{itemize}\n")
			for _, item := range rec.UseCases.Wav2Vec2Preferred {
				if item != "" {  // Filter out null/empty items
					content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
				}
			}
			content.WriteString("\\end{itemize}\n\n")
		}

		if len(rec.UseCases.BothAcceptable) > 0 {
			content.WriteString("\\subsubsection{When both models are acceptable}\n\\begin{itemize}\n")
			for _, item := range rec.UseCases.BothAcceptable {
				content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
			}
			content.WriteString("\\end{itemize}\n\n")
		}
	}

	// Features requiring human verification
	if len(rec.FeaturesRequiringHumanVerification) > 0 {
		content.WriteString("\\subsection{Features Requiring Human Verification}\n\\begin{itemize}\n")
		for _, item := range rec.FeaturesRequiringHumanVerification {
			content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	// Confidence thresholds
	if rec.ConfidenceThresholds != nil {
		content.WriteString("\\subsection{Confidence Thresholds}\n\\begin{itemize}\n")
		content.WriteString(fmt.Sprintf("\\item High confidence: %s\n", EscapeLaTeX(rec.ConfidenceThresholds.HighConfidenceThreshold)))
		content.WriteString(fmt.Sprintf("\\item Medium confidence: %s\n", EscapeLaTeX(rec.ConfidenceThresholds.MediumConfidenceThreshold)))
		content.WriteString(fmt.Sprintf("\\item Low confidence: %s\n", EscapeLaTeX(rec.ConfidenceThresholds.LowConfidenceThreshold)))
		content.WriteString("\\end{itemize}\n\n")
		content.WriteString(fmt.Sprintf("\\textbf{Rationale:} %s\n\n", EscapeLaTeX(rec.ConfidenceThresholds.Rationale)))
	}

	// System design implications
	if len(rec.SystemDesignImplications) > 0 {
		content.WriteString("\\subsection{System Design Implications}\n\\begin{itemize}\n")
		for _, item := range rec.SystemDesignImplications {
			content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	// Pedagogical considerations
	if len(rec.PedagogicalConsiderations) > 0 {
		content.WriteString("\\subsection{Pedagogical Considerations}\n\\begin{itemize}\n")
		for _, item := range rec.PedagogicalConsiderations {
			content.WriteString(fmt.Sprintf("\\item %s\n", EscapeLaTeX(item)))
		}
		content.WriteString("\\end{itemize}\n\n")
	}

	return content.String(), nil
}

// GenerateTables creates LaTeX tables from template and data
func (e *LaTeXExporter) GenerateTables(data *AnalysisResponse) (string, error) {
	tmplPath := filepath.Join(e.templateDir, "tables.tmpl")
	tmpl, err := template.ParseFiles(tmplPath)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %v", err)
	}

	// Prepare table data
	tableData := e.prepareTableData(data)

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tableData); err != nil {
		return "", fmt.Errorf("failed to execute template: %v", err)
	}

	return buf.String(), nil
}

// CreateZIPArchive creates a ZIP file from a directory
func CreateZIPArchive(sourceDir, zipPath string) (err error) {
	zipFile, err := os.Create(zipPath)
	if err != nil {
		return err
	}
	defer func() {
		if closeErr := zipFile.Close(); closeErr != nil && err == nil {
			err = closeErr
		}
	}()

	zipWriter := zip.NewWriter(zipFile)
	defer func() {
		// CRITICAL: zipWriter.Close() writes the ZIP central directory
		// If this fails, the entire ZIP file is corrupted
		if closeErr := zipWriter.Close(); closeErr != nil && err == nil {
			err = closeErr
		}
	}()

	return filepath.Walk(sourceDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return err
		}

		relPath, err := filepath.Rel(sourceDir, path)
		if err != nil {
			return err
		}

		zipEntry, err := zipWriter.Create(relPath)
		if err != nil {
			return err
		}

		fileContent, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		_, err = zipEntry.Write(fileContent)
		return err
	})
}

// DecodeAndSaveImages saves base64 images to PNG files
func DecodeAndSaveImages(images map[string]string, outputDir string) error {
	for chartName, base64Data := range images {
		// Remove data URL prefix if present
		if idx := strings.Index(base64Data, ","); idx != -1 {
			base64Data = base64Data[idx+1:]
		}

		imgData, err := base64.StdEncoding.DecodeString(base64Data)
		if err != nil {
			revel.AppLog.Errorf("Error decoding image %s: %v", chartName, err)
			continue
		}

		imgPath := filepath.Join(outputDir, fmt.Sprintf("%s.png", chartName))
		if err := os.WriteFile(imgPath, imgData, 0644); err != nil {
			revel.AppLog.Errorf("Error writing image %s: %v", chartName, err)
			continue
		}
	}
	return nil
}

// prepareTemplateData extracts and formats data for document template
func (e *LaTeXExporter) prepareTemplateData(data *AnalysisResponse) map[string]interface{} {
	templateData := make(map[string]interface{})

	// Model comparison stats - use Raw metrics for tables
	if data.ModelComparison != nil && data.ModelComparison.Raw != nil && data.ModelComparison.Raw.CERAnalysis != nil {
		templateData["ModelComparisonStats"] = e.formatModelComparisonStats(data.ModelComparison.Raw.CERAnalysis)
	}

	// Inter-rater reliability stats
	if data.InterRaterReliability != nil {
		templateData["InterRaterStats"] = e.formatInterRaterStats(data.InterRaterReliability)
	}

	return templateData
}

// prepareTableData extracts and formats data for tables template
func (e *LaTeXExporter) prepareTableData(data *AnalysisResponse) map[string]interface{} {
	tableData := make(map[string]interface{})

	// Model comparison table
	if data.ModelComparison != nil {
		tableData["ModelComparisonTable"] = e.formatModelComparisonTable(data.ModelComparison)
	}

	// Word difficulty table
	if data.WordDifficulty != nil {
		tableData["WordDifficultyTable"] = e.formatWordDifficultyTable(data.WordDifficulty)
	}

	return tableData
}

// Formatting helper methods

func (e *LaTeXExporter) formatModelComparisonStats(cerAnalysis *ErrorRateAnalysis) string {
	var buf bytes.Buffer

	// Descriptive statistics (single-participant study)
	whisperMean := cerAnalysis.Whisper.Mean
	wav2vec2Mean := cerAnalysis.Wav2Vec2.Mean
	difference := cerAnalysis.Difference.Mean
	cohensD := cerAnalysis.EffectSize.CohensD
	interpretation := cerAnalysis.EffectSize.Interpretation

	buf.WriteString(fmt.Sprintf("Whisper achieved a mean CER of %.2f\\%%, while Wav2Vec2 achieved %.2f\\%%.\n\n", whisperMean, wav2vec2Mean))
	buf.WriteString(fmt.Sprintf("Mean difference: %.2f\\%% (Whisper - Wav2Vec2).\n\n", difference))
	buf.WriteString(fmt.Sprintf("Effect size (Cohen's d): $d = %.3f$ (%s practical difference).\n\n", cohensD, interpretation))

	return buf.String()
}

func (e *LaTeXExporter) formatInterRaterStats(interRater *InterRaterReliabilityAnalysis) string {
	var buf bytes.Buffer

	buf.WriteString(fmt.Sprintf("Agreement rate: %.1f\\%%.\n\n", interRater.AgreementRate*100))

	if interRater.AgreementCounts != nil {
		buf.WriteString(fmt.Sprintf("Both models correct: %d instances.\n\n", interRater.AgreementCounts.BothCorrect))
		buf.WriteString(fmt.Sprintf("Both models incorrect: %d instances.\n\n", interRater.AgreementCounts.BothIncorrect))
		buf.WriteString(fmt.Sprintf("Whisper only correct: %d instances.\n\n", interRater.AgreementCounts.WhisperOnlyCorrect))
		buf.WriteString(fmt.Sprintf("Wav2Vec2 only correct: %d instances.\n\n", interRater.AgreementCounts.Wav2Vec2OnlyCorrect))
	}

	return buf.String()
}

func (e *LaTeXExporter) formatModelComparisonTable(modelComp *ModelComparisonAnalysis) string {
	var buf bytes.Buffer

	// Use Raw metrics for tables
	if modelComp.Raw != nil {
		if modelComp.Raw.WERAnalysis != nil {
			buf.WriteString(fmt.Sprintf("Mean WER (\\%%) & %.2f & %.2f \\\\\n",
				modelComp.Raw.WERAnalysis.Whisper.Mean, modelComp.Raw.WERAnalysis.Wav2Vec2.Mean))
		}

		if modelComp.Raw.CERAnalysis != nil {
			buf.WriteString("\\midrule\n")
			buf.WriteString(fmt.Sprintf("Mean CER (\\%%) & %.2f & %.2f \\\\\n",
				modelComp.Raw.CERAnalysis.Whisper.Mean, modelComp.Raw.CERAnalysis.Wav2Vec2.Mean))
		}
	}

	return buf.String()
}

func (e *LaTeXExporter) formatWordDifficultyTable(wordDiff *WordDifficultyAnalysis) string {
	var buf bytes.Buffer

	if wordDiff == nil || wordDiff.Raw == nil {
		return ""
	}

	// Iterate through most difficult words (top 10)
	for i, word := range wordDiff.Raw.MostDifficult {
		if i >= 10 {
			break
		}
		attempts := word.Count
		if attempts == 0 {
			attempts = word.Attempts
		}
		buf.WriteString(fmt.Sprintf("%s & %d & %.1f\\%% & %.1f\\%% \\\\\n",
			word.Word, attempts, word.WhisperAvgWER, word.Wav2Vec2AvgWER))
	}

	return buf.String()
}

// EscapeLaTeX escapes special LaTeX characters in strings
func EscapeLaTeX(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\textbackslash{}")
	s = strings.ReplaceAll(s, "&", "\\&")
	s = strings.ReplaceAll(s, "%", "\\%")
	s = strings.ReplaceAll(s, "$", "\\$")
	s = strings.ReplaceAll(s, "#", "\\#")
	s = strings.ReplaceAll(s, "_", "\\_")
	s = strings.ReplaceAll(s, "{", "\\{")
	s = strings.ReplaceAll(s, "}", "\\}")
	s = strings.ReplaceAll(s, "~", "\\textasciitilde{}")
	s = strings.ReplaceAll(s, "^", "\\textasciicircum{}")
	return s
}

// EscapeLaTeXShort formats short codes (like error attribution) as monospace
func EscapeLaTeXShort(s string) string {
	if s == "" {
		return "--"
	}
	return fmt.Sprintf("\\texttt{%s}", EscapeLaTeX(s))
}

// GenerateTranscriptionDocument creates a complete, compilable LaTeX document with transcription data
func GenerateTranscriptionDocument(entries []models.EntryWithUser) string {
	var buf bytes.Buffer

	// Document preamble
	buf.WriteString("\\documentclass[a4paper,10pt]{article}\n")
	buf.WriteString("\\usepackage[margin=0.5in,landscape]{geometry}\n")
	buf.WriteString("\\usepackage{longtable}\n")
	buf.WriteString("\\usepackage{booktabs}\n")
	buf.WriteString("\\usepackage[utf8]{inputenc}\n")
	buf.WriteString("\\usepackage[T1]{fontenc}\n\n")
	buf.WriteString("\\title{Welsh ASR Transcription Dataset}\n")
	buf.WriteString("\\date{\\today}\n\n")
	buf.WriteString("\\begin{document}\n\n")
	buf.WriteString("\\small % Reduce font size for better fit\n\n")

	// Table header definition (used for first page and continuation pages)
	const headerRow = "ID & User & Word & Whisper & Wav2Vec & Human & " +
		"WER\\textsubscript{W} & CER\\textsubscript{W} & Acc\\textsubscript{W} & Attr\\textsubscript{W} & " +
		"WER\\textsubscript{WV} & CER\\textsubscript{WV} & Acc\\textsubscript{WV} & Attr\\textsubscript{WV} \\\\\n"

	// Begin longtable (14 columns: ID, User, Word, Whisper, Wav2Vec, Human, 4 Whisper metrics, 4 Wav2Vec metrics)
	buf.WriteString("\\begin{longtable}{llllllllllllll}\n")
	buf.WriteString("\\caption{Complete Transcription Dataset for Welsh ASR Evaluation}\\label{tab:full-transcriptions} \\\\\n")

	// Header row (first page)
	buf.WriteString("\\toprule\n")
	buf.WriteString(headerRow)
	buf.WriteString("\\midrule\n")
	buf.WriteString("\\endfirsthead\n\n")

	// Continued header for subsequent pages
	buf.WriteString("\\multicolumn{14}{c}{\\tablename\\ \\thetable\\ -- continued from previous page} \\\\\n")
	buf.WriteString("\\toprule\n")
	buf.WriteString(headerRow)
	buf.WriteString("\\midrule\n")
	buf.WriteString("\\endhead\n\n")

	// Footer for page breaks
	buf.WriteString("\\midrule\n")
	buf.WriteString("\\multicolumn{14}{r}{Continued on next page} \\\\\n")
	buf.WriteString("\\endfoot\n\n")

	// Final footer
	buf.WriteString("\\bottomrule\n")
	buf.WriteString("\\endlastfoot\n\n")

	// Data rows
	for _, entry := range entries {
		// Escape all text fields for LaTeX
		username := EscapeLaTeX(entry.Username)
		word := EscapeLaTeX(entry.Text)
		whisper := EscapeLaTeX(entry.AttemptWhisper)
		wav2vec := EscapeLaTeX(entry.AttemptWav2Vec2)
		human := EscapeLaTeX(entry.HumanTranscription)
		if human == "" {
			human = "--"
		}
		attrW := EscapeLaTeXShort(string(entry.ErrorAttributionWhisper))
		attrWV := EscapeLaTeXShort(string(entry.ErrorAttributionWav2Vec2))

		// Format row: ID, User, Word, ASR outputs, metrics (14 columns)
		fmt.Fprintf(&buf, "%d & %s & %s & %s & %s & %s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %s & %.1f\\%% & %.1f\\%% & %.1f\\%% & %s \\\\\n",
			entry.ID, username, word, whisper, wav2vec, human,
			entry.WERWhisper, entry.CERWhisper, entry.TranscriptionAccuracyWhisper, attrW,
			entry.WERWav2Vec2, entry.CERWav2Vec2, entry.TranscriptionAccuracyWav2Vec2, attrWV)
	}

	buf.WriteString("\\end{longtable}\n\n")
	buf.WriteString("\\end{document}\n")
	return buf.String()
}

// generateHybridAnalysisSection generates LaTeX for the merged hybrid system analysis
// Combines best-case theoretical performance with practical implications for CAPT deployment
func (e *LaTeXExporter) generateHybridAnalysisSection(data *AnalysisResponse) (string, error) {
	var buf strings.Builder

	buf.WriteString("\\section{Hybrid System Analysis: Intelligent Model Selection for Welsh CAPT}\n\n")

	buf.WriteString("This section examines the theoretical upper bound of ASR performance achievable through ")
	buf.WriteString("intelligent per-word model selection, compared to deploying the best single fixed model. ")
	buf.WriteString("The analysis evaluates whether a hybrid ASR architecture offers meaningful practical value ")
	buf.WriteString("for Welsh Computer-Assisted Pronunciation Training (CAPT) systems.\n\n")

	// Note about data sources
	buf.WriteString("\\textbf{Note:} This analysis synthesizes data from both the \\textit{Hybrid Best-Case} ")
	buf.WriteString("and \\textit{Hybrid Practical Implications} Python API endpoints. Charts referenced below ")
	buf.WriteString("are included in the accompanying \\texttt{charts/} directory.\n\n")

	buf.WriteString("\\subsection{Overall Performance Summary}\n\n")
	buf.WriteString("The hybrid approach represents the best possible performance if an intelligent system ")
	buf.WriteString("could select the optimal ASR model and normalization strategy for each individual word.\n\n")

	buf.WriteString("\\textbf{Key Metrics:}\n")
	buf.WriteString("\\begin{itemize}\n")
	buf.WriteString("\\item Best Single Model: Performance of the most accurate fixed configuration\n")
	buf.WriteString("\\item Hybrid Best-Case: Performance achieved through intelligent per-word selection\n")
	buf.WriteString("\\item Absolute Improvement: Reduction in CER percentage points\n")
	buf.WriteString("\\item Relative Improvement: Proportional error reduction rate\n")
	buf.WriteString("\\end{itemize}\n\n")

	buf.WriteString("Detailed performance comparison charts are available in \\texttt{charts/chartHybridAnalysis.png}.\n\n")

	buf.WriteString("\\subsection{Critical CAPT Areas: Detailed Comparison}\n\n")
	buf.WriteString("The hybrid system's impact varies across different phonological and pedagogical contexts. ")
	buf.WriteString("Three critical areas were analyzed:\n\n")

	buf.WriteString("\\subsubsection{Welsh Digraphs (ll, ch, dd, ff, ng, rh, ph, th)}\n\n")
	buf.WriteString("Welsh digraphs represent unique phonological challenges not present in English. ")
	buf.WriteString("These two-letter combinations produce single sounds critical to Welsh pronunciation. ")
	buf.WriteString("Accurate recognition of digraphs is essential for effective CAPT feedback on ")
	buf.WriteString("learner-specific phonological features.\n\n")

	buf.WriteString("\\subsubsection{Most Difficult Words}\n\n")
	buf.WriteString("The top 10 most challenging words (highest average CER across all recordings) ")
	buf.WriteString("represent pedagogically critical vocabulary where ASR errors most impact learner feedback. ")
	buf.WriteString("Hybrid improvements in this category directly address the most problematic cases.\n\n")

	buf.WriteString("\\subsubsection{Error Reduction Potential}\n\n")
	buf.WriteString("This metric quantifies how many ASR errors are \\textit{preventable} through hybrid selection")
	buf.WriteString("cases where one model transcribed correctly while the best single model failed. ")
	buf.WriteString("High preventable error rates indicate strong practical value for hybrid deployment.\n\n")

	buf.WriteString("\\subsection{Statistical Analysis}\n\n")
	buf.WriteString("\\subsubsection{Effect Size (Cohen's d)}\n\n")
	buf.WriteString("Cohen's d measures the practical significance of the hybrid system's improvement, ")
	buf.WriteString("standardized by pooled standard deviation. Effect size interpretation:\n\n")

	buf.WriteString("\\begin{itemize}\n")
	buf.WriteString("\\item $|d| < 0.2$: Negligible effect\n")
	buf.WriteString("\\item $0.2 \\leq |d| < 0.5$: Small effect\n")
	buf.WriteString("\\item $0.5 \\leq |d| < 0.8$: Medium effect\n")
	buf.WriteString("\\item $|d| \\geq 0.8$: Large effect\n")
	buf.WriteString("\\end{itemize}\n\n")

	buf.WriteString("Effect size provides context beyond raw percentage improvements, indicating whether ")
	buf.WriteString("observed gains are academically and pedagogically meaningful.\n\n")

	buf.WriteString("\\subsubsection{Sample Characteristics}\n\n")
	buf.WriteString("The analysis is based on recordings where all four ASR configurations ")
	buf.WriteString("(Whisper Raw, Whisper Normalized, Wav2Vec2 Raw, Wav2Vec2 Normalized) ")
	buf.WriteString("successfully produced transcriptions, ensuring fair comparison.\n\n")

	buf.WriteString("\\subsection{Academic Interpretation}\n\n")
	buf.WriteString("The hybrid system analysis examines theoretical performance bounds achievable through ")
	buf.WriteString("intelligent model selection. Key considerations for interpretation:\n\n")

	buf.WriteString("\\begin{enumerate}\n")
	buf.WriteString("\\item \\textbf{Theoretical vs. Practical}: Results represent the \\textit{best possible} ")
	buf.WriteString("hybrid performance, assuming perfect model selection for each word. Real-world ")
	buf.WriteString("implementation would require a selection mechanism (e.g., confidence scores, ")
	buf.WriteString("word-specific rules, or meta-learning), which may not achieve 100\\% optimal choices.\n\n")

	buf.WriteString("\\item \\textbf{Implementation Complexity}: A hybrid system adds architectural complexity, ")
	buf.WriteString("requiring additional infrastructure for model orchestration, result aggregation, ")
	buf.WriteString("and selection logic. Benefits must justify this increased system complexity.\n\n")

	buf.WriteString("\\item \\textbf{Computational Cost}: Running multiple ASR models increases computational ")
	buf.WriteString("requirements. For real-time CAPT applications, latency and resource consumption must be ")
	buf.WriteString("evaluated against accuracy improvements.\n\n")

	buf.WriteString("\\item \\textbf{Pedagogical Value}: Error reduction is most valuable for ")
	buf.WriteString("\\textit{pedagogically critical} contextsWelsh-specific phonology (digraphs), ")
	buf.WriteString("difficult vocabulary, and edge cases where false feedback would mislead learners.\n")
	buf.WriteString("\\end{enumerate}\n\n")

	buf.WriteString("\\subsection{Deployment Recommendation}\n\n")
	buf.WriteString("The deployment recommendation synthesizes average improvement across critical areas ")
	buf.WriteString("with effect size magnitude to provide evidence-based guidance:\n\n")

	buf.WriteString("\\begin{itemize}\n")
	buf.WriteString("\\item \\textbf{Strongly Recommended (avg improvement $\\geq$ 20\\%, d $\\geq$ 0.5):} ")
	buf.WriteString("Substantial gains justify hybrid complexity for accuracy-prioritized Welsh CAPT.\n\n")

	buf.WriteString("\\item \\textbf{Recommended (avg improvement $\\geq$ 10\\%, d $\\geq$ 0.3):} ")
	buf.WriteString("Meaningful improvements, especially for difficult words and Welsh digraphs, ")
	buf.WriteString("beneficial for pedagogically-focused applications.\n\n")

	buf.WriteString("\\item \\textbf{Consider with Caution (avg improvement $\\geq$ 5\\%):} ")
	buf.WriteString("Modest gains may justify implementation for research or high-stakes assessment contexts, ")
	buf.WriteString("but cost-benefit analysis required for production deployment.\n\n")

	buf.WriteString("\\item \\textbf{Not Critical (avg improvement $<$ 5\\%):} ")
	buf.WriteString("Marginal improvements do not justify hybrid complexity. Best single model sufficient ")
	buf.WriteString("for most CAPT applications.\n")
	buf.WriteString("\\end{itemize}\n\n")

	buf.WriteString("See accompanying chart \\texttt{charts/chartHybridAnalysis.png} for visual comparison ")
	buf.WriteString("of performance across critical areas.\n\n")

	return buf.String(), nil
}
